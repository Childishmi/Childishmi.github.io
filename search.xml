<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[初识Java2.2_Tips]]></title>
    <url>%2F2017%2F07%2F28%2F%E5%88%9D%E8%AF%86Java2.2_Tips_2017-7-28%2F</url>
    <content type="text"><![CDATA[Tips for ‘package &amp;&amp; import’情景 //Cat.java package com.bjsxt.java140; public class Cat{} //若此public不写则编译Dog.java时 用Cat 会报错! (默认为protected) Error &amp;&amp; Solution✿Q1：E:\chapter1\testpackage&gt;javac Dog.java 请删除该文件或确保该文件位于正确的类路径子目录中。 //Dog.java public class Dog{ public static void main(String[] args){ Cat c = new Cat(); } } ✔A1：保证.\com\bjxst\java140目录下有个Cat.class ,可把源文件Cat.java删了,源码可能会产生影响 ✿Q2：仍报错 can&#39;t resolve symbol不能解析符号, 找不到符号(这个类我不认识它)✔A2： //testPackage\Dog.java public class Dog{ public static void main(String[] args){ com.bjsxt.java140.Cat c = new com.bjsxt.java140.Cat(); } } ✿Q3：E:\chapter1&gt;javac TestPack.javaTestPack.java:1: 错误: 程序包com.bjsxt.java140不存在 //E:\chapter1\TestPack.java import com.bjsxt.java140.Cat; public class TestPack { public static void main(String[] args) { Cat c = new Cat(); } } ✔A3： com的上一层 (即testpackage) 和TestPack.java得在同一个目录下 才能找着 设置classpath 变量值新增为E:\chapter1\testpackage 即com的上一层目录 E:\chapter1&gt;javac TestPack.java✔ ✿Q4：错误: 找不到或无法加载主类 Dog //Dog.java package com.bjsxt.java139; import com.bjsxt.java140.*; public class Dog { public static void main(String[] args) { Cat c = new Cat(); } } E:\chapter1\testpackage&gt;javac Dog.java编译好后,把Dog.class放在E:\chapter1\testpackage\com\bjsxt\java139里面 E:\chapter1\testpackage&gt;java Dog错误: 找不到或无法加载主类 Dog ✔A4：写全了 E:\chapter1\testpackage&gt;java com.bjsxt.java139.Dog ✿Q5： c:&gt; 找不着✔A5： 写全+包上一层目录所在路径设置在classpath ✔Summary: 把一个类放包里 要把class放在正确的目录下面; 每个企业域名是唯一的; Cat.java 第一句: package com.bjsxt.java140; 如果想在另一个类里用包里这个类，要把名字写全了，or还以为你用的是裸体类 Q2过后太繁琐-&gt;Dog.java里开头 简写import com.bjsxt.java140.Cat; 即引入类Cat,则Dog.java中Cat c = new Cat();✔ 或import com.bjsxt.java140.*; 即引入java140中所有类,则Dog.java中Cat c = new Cat();✔ Cat的最上层包com 所在父目录是testPackage 它必须位于classpath下 ◎◎◎好几个项目下 冲突-&gt;待解决 Eclipse 不同项目设置不同的classpath 互相之间不会影响 ♚ 如果想将一个类Cat放入包中，在这个类Cat源文件第一句话写package ♚ 必须保证该类的classpath位于正确目录下 ☁ 该类的源码Cat.java可能会产生影响 ☁ 删除或转移到另外的目录 ♚ 如果另外的类Dog想访问： ☁ 写全名 ☁ 引入 ☁ 具体类名 ☁ * ☁ 访问位于同一个包中的类不需要引入 ♚ 必须 class文件的 最上层包的 父目录 位于classpath下 ♚ 执行一个类需要写全包名 ✿Q6：E:\jdk1.8\jre\lib\rt.jar Java运行时需要的所有class文件都在rt.jar中,想看✔A6： 打开方式 选压缩文件 (jar包其实就是个classpath) ✿Q7：把自己的类打成jar包✔A7： 定位到com最上层包的最上层路径里jar -cvf test.jar * 或 jar -cvf test.jar com\ 或 jar -cvf test.jar com/ ‘*’: 把当前目录下所有的子目录及其中的文件都打包到jar文件里 jar -c 创建新档案 -v 在标准输出中生成详细输出 -f 指定档案文件名 E:\chapter1\testpackage>jar -cvf test.jar * 已添加清单 正在添加: com/(输入 = 0) (输出 = 0)(存储了 0%) 正在添加: com/bjsxt/(输入 = 0) (输出 = 0)(存储了 0%) 正在添加: com/bjsxt/java139/(输入 = 0) (输出 = 0)(存储了 0%) 正在添加: com/bjsxt/java139/Dog.class(输入 = 313) (输出 = 237)(压缩了 24%) 正在添加: com/bjsxt/java140/(输入 = 0) (输出 = 0)(存储了 0%) 正在添加: com/bjsxt/java140/Cat.class(输入 = 198) (输出 = 170)(压缩了 14%) ✿Q8：把自己的类打成jar包 java com.bjsxt.java139.Dog 却找不着报错了✔A8： 设置classpath新增 E:\chapter1\testpackage\test.jar ,好处：则任意目录下可运行D:\&gt;java com.bjsxt.java139.Dog✔]]></content>
      <categories>
        <category>java,Tips</category>
      </categories>
      <tags>
        <tag>2017Summer</tag>
        <tag>java</tag>
        <tag>Tips</tag>
        <tag>package</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初识Java2.1_基础语法]]></title>
    <url>%2F2017%2F07%2F27%2F%E5%88%9D%E8%AF%86Java2.1_%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95_2017-7-27%2F</url>
    <content type="text"><![CDATA[基础语法内存分四块区域 heap(堆，new出来的东西), stack(栈，局部变量), data segment(静态变量，字符串常量), code segment(存放代码) 成员变量 &amp;&amp; 局部变量 成员变量（在方法体外，类体里，相当于C中的全局变量） 默认初始化0 static 局部变量 需要自己初始化 进制 Java Unicode，每个字符两字节，十六进制 十六进制61=01100001（0110=4+2=61=0001），0x开头 二进制-十进制-十六进制的转换 1101（=8+4+0+1）=13=D 所有数都带符号（C中却有unsigned）有一位表符号 所以byte (-2^7,2^7-1) Java中所有数据类型在所有的操作系统中占的字节数大小均相同，编译完成后可移植(C中不可) 整形常量默认int，若要long，需加L byte(1字节),short(2),int(4),long(8) char c=&#39;\u534e&#39;; //Unicode中是‘华’,4+0+1 0101 ,2+1 0011,4+0+0 0100,e=14=8+4+2+0 1110 自动 &amp;&amp; 强制转换 容量（表示的数的大小）小的数据类型自动转换成容量大的，数据类型按容量大小：byte,short,char-&gt;int-&gt;long-&gt;float-&gt;double boolean不参与转换 int可直接转换为byte,short,char,只要不超出范围 byte b1=127; //int-&gt;byte byte,short,char做运算时首先自动把自己转换为int,做运算时要加强制转换符 byte b2=-1; byte b3=(byte)(b1+b2);//系统将转换为int运算，需要强制转换符 double-&gt;float（大-&gt;小）可能会降精度/溢出Infinity ; int-&gt;byte可以直接把前三个字节砍掉变为0 不会infinity byte b1=67;byte b1=89;byte b3=(byte)(b1+b2); //b3==-100-eg: public class TestConvert2 { public static void main(String[] args) { int i=1,j=12; float f1=(float)0.1; //0.1f float f2=123; long l1 = 12345678,l2=8888888888L; double d1 = 2e20,d2=124; byte b1 = 1,b2 = 2,b3 = 127; j = j+10; i = i/10; i = (int)(i*0.1); char c1='a',c2=125; byte b = (byte)(b1-b2); char c = (char)(c1+c2-1); float f3 = f1+f2; float f4 = (float)(f1+f2*0.1); double d = d1*i+j; float f = (float)(d1*5+d2); } } 自增、自减运算符eg: int i1 = 10 , i2 = 20 ; int i = (i2++) ; //i==20;i2==21; i = (++i2) ; //i==22;i2==22; i = (--i1) ; //i==9;i1==9; i = (i1--) ; //i==9;i1==8; for循环 for循环 表达式1-表达式2(true)-语句-表达式3-表达式2(true)… 直到表达式2(false) 结束for循环 eg:输出101~200以内的质数 public class Test { public static void main (String args[]) { for (int i = 101 ; i < 200 ; i += 2) { boolean f = true; for (int j = 3 ; j < i ; j++) { if (i % j == 0) { f = false ; //能被整除 不是质数 break; //跳出里面一层for循环 } } if (!f) { continue; } //若不是质数 继续下一次循环 System.out.print (i + " " ) ; } } }]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>2017Summer</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初识Java2.0_前言]]></title>
    <url>%2F2017%2F07%2F26%2F%E5%88%9D%E8%AF%86Java2.0_%E5%89%8D%E8%A8%80_2017-7-26%2F</url>
    <content type="text"><![CDATA[前言C &amp;&amp; Java 区别 C,C++-&gt;编译型, 可直接编译成为操作系统能认识的 Java-&gt;解释型, .Java先编译成自己的可执行.class,拿一行解释一行（各操作系统均可识别的） 两种机制 虚拟机 一次编译，到处运行，帮我们实现了跨平台（体现了分层思想，把底层屏蔽了，接口统一了，更便于编程） 垃圾收集（自动进行 无需delete，每隔一阵，全回收）程序的健壮性 名词 J2SDK，JDK（软件开发包software development kit） 开发需要JDK，JDK包含了JRE JRE（运行环境runtime environment） 用户只需JRE bin(binary编译好的，可以运行的程序) lib(library库文件) src.zip（source Java的源代码） dir 目录 .表示当前路径 Path（Windows系统执行命令时要搜索的路径） Javac会去path的环境变量里找 ;的各个目录去找 看看有没有相应的可执行文件 有-执行Javac命令，没有-不认识这个命令，则编辑系统变量的变量值 在前面加上路径+;即可 重启命令提示符敲Javac 即新版本 java -version Windows支持多用户 计算机-环境变量-上面是用户自己的环境变量Administrator的用户变量-下面是系统变量（所有用户可用的） Classpath（Java在编译和运行时要找的class所在的路径） 一个class要寻找另一个class去哪找？-&gt;classpath环境变量中去找 jdk1.5后并不太依赖它了 编辑器 UltraEdit-32 集成开发环境IDE 编译 运行 调试 全在一个程序下执行 开发平台（Eclipse…） 其它 ٩(๑❛ᴗ❛๑)۶ C:\Users>e: E:\>cd chapter1 E:\chapter1>javac HelloWorld.java E:\chapter1>java HelloWorld HelloWorld!]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>2017Summer</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初识Java_第五天]]></title>
    <url>%2F2017%2F07%2F19%2F%E5%88%9D%E8%AF%86Java_%E7%AC%AC%E4%BA%94%E5%A4%A9_2017-7-19%2F</url>
    <content type="text"><![CDATA[接口与实现interface (๑•ω•̀๑） interface来定义一个接口。 接口体中包含常量定义(接口中不能有变量)和方法定义两部分。接口体中只进行方法的声明，不许提供方法的实现。 interface Printable { final int MAX=100; void add(); float sum(float x ,float y); } 接口的变量和方法的构成规则 (๑´ㅂ`๑) 接口中的变量自动都是public、static、final. 接口中的方法默认为public abstract；接口也产生class文件. 接口中的方法不能被static和final修饰，因为要重写所有接口中的方法. 接口中没有构造函数，方法可以抛出异常. 实现接口 (๑´ㅂ`๑) 一个类通过使用关键字implements声明自己实现一个或多个接口。如：public class China implements Computable //China类实现Computable接口 如果一个类实现了某个接口，那么这个类必须重写该接口的所有方法。 接口可以通过继承产生新的接口。 Java提供的接口都在相应的包中，通过import语句不仅可以引入包中的类，也可以引入包中的接口，如: import java.io.*; eg: MotorVehicles类（机动车）的子类Taxi（出租车）和Bus（公共汽车）必须有brake的方法（刹车功能）.但额外要求Taxi类有controlAirTemperature和charge的方法（空调和收费功能），即要求Taxi实现两个接口;要求客车类有名字为charge的方法（有收费功能），即要求Bus只实现一个接口。 abstract class MotorVehicles { abstract void brake(); } interface MoneyFare { void charge(); } interface ControlTemperature { void controlAirTemperature(); } class Bus extends MotorVehicles implements MoneyFare { void brake() { System.out.println("公共汽车使用毂式刹车技术"); } public void charge() { System.out.println("公共汽车:一元/张,不计算公里数"); } } class Taxi extends MotorVehicles implements MoneyFare,ControlTemperature { void brake() { System.out.println("出租车使用盘式刹车技术"); } public void charge() { System.out.println("出租车:2元/公里,起价3公里"); } public void controlAirTemperature() { System.out.println("出租车安装了Hair空调"); } } class Cinema implements MoneyFare,ControlTemperature { public void charge() { System.out.println("电影院:门票,十元/张"); } public void controlAirTemperature() { System.out.println("电影院安装了中央空调"); } } public class Example6_3 { public static void main(String args[]) { Bus bus101 = new Bus(); Taxi buleTaxi = new Taxi(); Cinema redStarCinema = new Cinema(); MoneyFare fare; ControlTemperature temperature; fare = bus101; bus101.brake(); fare.charge(); fare = buleTaxi; temperature = buleTaxi; buleTaxi.brake(); fare.charge(); temperature.controlAirTemperature(); fare = redStarCinema; temperature = redStarCinema; fare.charge(); temperature.controlAirTemperature(); } } 公共汽车使用毂式刹车技术 公共汽车:一元/张,不计算公里数 出租车使用盘式刹车技术 出租车:2元/公里,起价3公里 出租车安装了Hair空调 电影院:门票,十元/张 电影院安装了中央空调 接口参数 ٩(๑❛ᴗ❛๑)۶ 如果一个方法lookHello的参数是接口SpeakHello类型，我们就可以将任何实现该SpeakHello接口的类Chinese,English的实例的引用new()传递给该接口参数，那么接口参数就可以回调类实现的接口方法void speakHello();。 eg: interface SpeakHello { void speakHello(); } class Chinese implements SpeakHello { //实现SpeakHello接口的类 public void speakHello() { System.out.println("中国人习惯问候语：你好,吃饭了吗? "); } } class English implements SpeakHello { //实现SpeakHello接口的类 public void speakHello() { System.out.println("英国人习惯问候语:Hello."); } } class KindHello { public void lookHello(SpeakHello h) { //接口类型参数 h.speakHello(); //接口回调 } } public class Example6_5 { public static void main(String args[]) { KindHello kindhello3=new KindHello(); kindhello3.lookHello(new Chinese()); //将 实现该接口的类 的实例的引用 传递给该接口参数 kindhello3.lookHello(new English()); } } 中国人习惯问候语：你好,吃饭了吗? 英国人习惯问候语:Hello. 其他 ( • ̀ω•́ )eg: 主类(Example6_6),Avertisemen接口,实现该接口的WhiteCloudCorp（白云公司）,BlackLandCorp（黑土公司）,面向接口的AdvertisementBoard类（广告牌） public interface Advertisement { //接口 public void showAdvertisement(); public String getCorpName(); } public class WhiteCloudCorp implements Advertisement { //PhilipsCorp实现Avertisement接口 public void showAdvertisement(){ System.out.printf("***白云，飞机中的战斗机!***\n"); } public String getCorpName() { return "白云有限公司" ; } } public class BlackLandCorp implements Advertisement { public void showAdvertisement(){ System.out.printf("***黑土，劳动是爹，土地是妈***\n"); } public String getCorpName() { return "黑土集团" ; } } public class AdvertisementBoard { //负责创建广告牌 public void show(Advertisement ad) { System.out.println(ad.getCorpName()+"的广告词如下:"); ad.showAdvertisement(); //接口回调 } } public class Example6_6 { public static void main(String args[]) { AdvertisementBoard board = new AdvertisementBoard(); board.show(new BlackLandCorp()); board.show(new WhiteCloudCorp()); } } 黑土集团的广告词如下: ***黑土，劳动是爹，土地是妈*** 白云有限公司的广告词如下: ***白云，飞机中的战斗机!*** 体验٩(•̤̀ᵕ•̤́๑) 接口什么的和C++还是有很大不同的 费解 加油]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>2017Summer</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初识Java_第四天]]></title>
    <url>%2F2017%2F07%2F18%2F%E5%88%9D%E8%AF%86Java_%E7%AC%AC%E5%9B%9B%E5%A4%A9_2017-7-18%2F</url>
    <content type="text"><![CDATA[子类与继承子类与父类 (๑•ω•̀๑） 不支持多重继承（子类只能有一个父类）. class Student extends People { //子类Student 继承自 父类People ... } Object是所有类的祖先类. 除了Object类，每个类都有且仅有一个父类. 如果一个类（除了Object类）的声明中没有使用extends，这个类被系统默认为是Object的子类，即类声明“class A”与“class A extends Object”是等同的。 super (๑´ㅂ`๑) 如果在子类中想使用被子类隐藏的成员变量或方法就可以使用关键字super。比如super.x。 使用super调用父类的构造方法 子类不继承父类的构造方法，因此，子类如果想使用父类的构造方法，必须在子类的构造方法中使用，并且必须使用关键字super来表示，而且super必须是子类构造方法中的头一条语句。eg: class Student { int number; String name; Student() { } Student(int number,String name) { this.number=number; this.name=name; System.out.println("我的名字是:"+name+ "学号是:"+number); } } class UniverStudent extends Student { boolean 婚否; UniverStudent(int number,String name,boolean b) { super(number,name); 婚否=b; System.out.println("婚否="+婚否); } } public class Example5_8 { public static void main(String args[]) { UniverStudent zhang=new UniverStudent(9901,"何晓林",false); } } final ٩(๑❛ᴗ❛๑)۶ final关键字可以修饰类、成员变量和方法中的局部变量. final类不能被继承，即不能有子类. final class A {...} 如果用final修饰父类中的一个方法，那么这个方法不允许子类重写. 如果成员变量或局部变量被修饰为final的，就是常量.eg: final double PI=3.14; public double getArea(final double r) { return PI*r*r; } 对象的上转型对象 ( • ̀ω•́ ) A类是B类的父类，当用子类B创建一个对象b，并把这个对象b的引用放到父类A的对象a中时，称对象a是对象b的上转型对象.eg: A a; //父类 a=new B(); //把子类对象b的引用放到父类A的对象a中 或 A a; B b=new B(); a=b; ###上转型对象的使用 上转型对象不能操作子类新增的成员变量；不能调用子类新增的方法。 上转型对象可以访问子类继承或隐藏的成员变量，也可以调用子类继承的方法或子类重写的实例方法。 如果子类重写了父类的某个实例方法后，当用上转型对象调用这个实例方法时，一定是调用了子类重写的实例方法。 对象的上转型对象 对象 隐藏的变量 ✿ 继承的变量 ✿ ✿ 新增的变量 ✿ 继承或重写的方法 ✿ ✿ 新增的方法 ✿ eg: class 类人猿 { void Speak(String s) { System.out.println(s); } } class People extends 类人猿 { void computer(int a,int b) { int c=a*b; System.out.println(c); } void Speak(String s) { System.out.println("***"+s+"***"); } } public class Example5_10 { public static void main(String args[]) { 类人猿 monkey; People p1 = new People(); monkey = p1 ; //monkey是People对象p1的上转型对象 monkey.crySpeak("I love this game");//等同于geng.crySpeak("I love this game"); People p2=(People)monkey; //把上转型对象强制转化为子类的对象 p2.computer(10,10); } } ***I love this game*** 100 abstract ٩(๑❛ᴗ❛๑)۶ 抽象方法abstract int min(int x,int y); 对于abstract方法，只允许声明，不允许实现，而且不允许使用final修饰abstract方法。 抽象类 abstract class A { ... } 对于abstract类，不能使用new运算符创建该类的对象，只能产生其子类，由子类创建对象。 如果一个类是abstract类的子类，它必须具体实现父类的所有的abstract方法。eg: abstract class GirlFriend { abstract void speak(); abstract void cooking(); } class ChineseGirlFriend extends GirlFriend { void speak(){ System.out.println("你好"); } void cooking(){ System.out.println("水煮鱼"); } } class AmericanGirlFriend extends GirlFriend { void speak(){ System.out.println("hello"); } void cooking(){ System.out.println("roast beef"); } } class Boy { GirlFriend m_friend; void setGirlfriend(GirlFriend f){ m_friend = f; } void showGirlFriend() { m_friend.speak(); m_friend.cooking(); } } public class Example5_12 { public static void main(String args[]) { GirlFriend lily = new ChineseGirlFriend(); //lily是上转型对象 Boy boy = new Boy(); boy.setGirlfriend(lily); boy.showGirlFriend(); lily = new AmericanGirlFriend(); //lily是上转型对象 boy.setGirlfriend(lily); boy.showGirlFriend(); } } 你好 水煮鱼 hello roast beef 体验٩(•̤̀ᵕ•̤́๑) 加油]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>2017Summer</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初识Java_第三天]]></title>
    <url>%2F2017%2F07%2F17%2F%E5%88%9D%E8%AF%86Java_%E7%AC%AC%E4%B8%89%E5%A4%A9_2017-7-17%2F</url>
    <content type="text"><![CDATA[类与对象成员变量与局部变量 (๑•ω•̀๑） 成员变量（类体中变量定义部分所定义的变量）： 在整个类内有效，定义时有默认值. 静态变量（类变量） static 实例变量（实例成员变量） 其他 局部变量（在方法体中定义的变量和方法的参数）： 只在方法内有效，定义时没有默认值(因此在使用局部变量之前,必须保证局部变量有具体的值). 如果局部变量的名字与成员变量的名字相同，则成员变量被隐藏，即该成员变量在这个方法内暂时失效。eg1: class Tom { int x = 10,y; void f() { int x = 5; y = x+x; //y得到的值是10，不是20。 //如果方法f 中没有“int x=5;”，y的值将是20 } } 如果想在该方法中使用被隐藏的成员变量，必须使用关键字thiseg2: class Tom { int x = 10,y; void f() { int x = 5; y = x+this.x; //y得到的值是15 } } 方法 (๑´ㅂ`๑) 类方法（有static）eg: static int add(int a,int b){ return a+b;} 只能对类变量进行操作, 只能调用该类的类方法 实例方法 既能对类变量操作也能对实例变量操作, 可以调用该类中的其他方法 定义类时需要注意 ٩(๑❛ᴗ❛๑)۶ 对成员变量的操作只能放在方法中，在声明成员变量时可同时赋初值，但是不可以在类体中有单独的赋值语句，但局部变量必须赋初值。eg: class A { int a=12; //ok int b; b=12; //error } 创建对象 ( • ̀ω•́ ) 对象的声明 为对象分配变量 eg1： class A { float height,weight; String head, ear; void speak(String s) { System.out.println(s); } } public class Example4_1 { public static void main(String args[]) { A zhubajie; //声明对象 zhubajie = new A(); //为声明的对象分配变量 } } eg2: class Point { int m_x,m_y; Point(int x,int y) { m_x=x; m_y=y; } } public class Example4_2 { public static void main(String args[]) { Point p1,p2; //声明对象p1和p2 p1=new Point(10,10); //为对象分配变量(使用new和类中的构造方法) p2=new Point(23,35); //为对象分配变量(使用new和类中的构造方法) } } package ٩(๑❛ᴗ❛๑)۶为源文件中声明的类指定包名。package tom.jiafei; //程序如果使用了包语句…\tom\jiafei //那么存储文件的目录结构中必须包含该结构 eg: E:\chapter1\tom\jiafei 并且要将源文件编译得到的类的字节码文件保存在目录E:\chapter1\tom\jiafei中（源文件可以任意存放） 运行有包名的主类 主类的包名是tom.jiafei，那么主类的字节码一定存放在…\tom\jiefei目录中，运行时必须到tom\jiefei的上一层（即tom的父目录）目录中去运行主类。 tom\jiefei的上一层目录是chapter1，那么，必须如下格式来运行：E:\chapter1\java tom.jiafei.主类名 E:\chapter1&gt;javac tom\jiafei\Example4_15.java E:\chapter1&gt;java tom.jiafei.Example4_15 import (๑•ω•̀๑） 如果一个类想要使用的那个类 和它不在一个包中，要使用import语句。 import java.util.*; //表示引入java.util包中所有的类 Java.util包包含有用的数据类型类 引入自定义包中的类 使用import语句引入非类库中有包名的类，如：import tom.jiafei.*; //E:\chapter1\sohu\com\Triangle.java package sohu.com; public class Triangle { double sideA,sideB,sideC; public double getArea() { double p = (sideA+sideB+sideC)/2.0; double area = Math.sqrt(p*(p-sideA)*(p-sideB)*(p-sideC)) ; return area; } public void setSides(double a,double b,double c) { sideA = a; sideB = b; sideC = c; } } //E:\chapter1\hello\nihao\Example4_18.java package hello.nihao; import sohu.com.Triangle; public class Example4_18 { public static void main(String args[]) { Triangle tri = new Triangle(); tri.setSides(30,40,50); System.out.println(tri.getArea()); } } E:\chapter1&gt;javac hello\nihao\Example4_18.java E:\chapter1&gt;java hello.nihao.Example4_18 600.0 private &amp; public等 (๑•ω•̀๑） public class定义的类-&gt;public类 不加public修饰的类 -&gt;友好类 private 某个类在另外一个类中创建对象后，如果不希望该对象直接访问（通过“.”运算符来操作）自己的成员变量，就应当将该成员变量访问权限设置为private 作用域 当前类 同一package 子孙类 其他package public yes yes yes yes protected yes yes yes no friendly yes yes no no private yes no no no 对基本数据类型的封装 (๑•ω•̀๑） java.lang包 Byte、Integer、Short、Long、Float、Double和Character类 Double对象调用doubleValue()方法可以返回该对象中含有的double型数据。 eg: double m1=d1.doubleValue(); if(Character.isLowerCase(a[i])) a[i]=Character.toUpperCase(a[i]); 对象数组 (๑•ω•̀๑）Student [] stu = new Student[10]; //数组的元素是对象Student stu1,stu2… 这些对象目前都是空对象.stu[i]=new Student(); //使用数组stu中的对象之前，应当创建数组所包含的对象。 其他 (๑•ω•̀๑）反编译和文档生成器 javap.exe将字节码反编译为源码，以便查看源码类中的public方法名字和public成员变量的名字 javap Example4_20.class Compiled from "Example4_20.java" public class Example4_20 { public Example4_20(); public static void main(java.lang.String[]); } javadoc.exe可以制做源文件类结构的html格式文档 javadoc Example4_20.java 正在加载源文件Example4_20.java... 正在构造 Javadoc 信息... 标准 Doclet 版本 1.8.0_131 正在构建所有程序包和类的树... 正在生成.\Example4_20.html... 正在生成.\package-frame.html... 正在生成.\package-summary.html... 正在生成.\package-tree.html... 正在生成.\constant-values.html... 正在构建所有程序包和类的索引... 正在生成.\overview-tree.html... 正在生成.\index-all.html... 正在生成.\deprecated-list.html... 正在构建所有类的索引... 正在生成.\allclasses-frame.html... 正在生成.\allclasses-noframe.html... 正在生成.\index.html... 正在生成.\help-doc.html... 体验٩(•̤̀ᵕ•̤́๑) 加油]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>2017Summer</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初识Java_第二天2]]></title>
    <url>%2F2017%2F07%2F16%2F%E5%88%9D%E8%AF%86Java_%E7%AC%AC%E4%BA%8C%E5%A4%A92_2017-7-16%2F</url>
    <content type="text"><![CDATA[#运算符、表达式和语句 自增、自减运算符：++，– (๑•ω•̀๑） ++x 表示在使用x之前，先使x的值增1。 x++ 表示在使用x之后，使x的值增1。 eg: int f=2; int m=2; int x=(fm++)+m; //x=7; 22 +3 int y=(f++m)+m; //y=9; 23 +3 instanceof (๑´ㅂ`๑) 左-对象；右-类。当左面的对象是右面的类或子类创建的对象时，该运算符结果是true ，否则是false。eg: String s=new String(“abc”); if(s instanceof String) System.out.println(“s is a string”); switch ٩(๑❛ᴗ❛๑)۶ switch 语句是单条件多分支的开关语句 表达式的值必须是：byte，short，int，char。 不能是String或者long型的（与int兼容类型）。 必须要有break语句 default语句放的位置是任意的。 break &amp; continue ( • ̀ω•́ )eg： public class Example3_7 { public static void main(String args[]) { int sum=0,i,j; for( i=1;i]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>2017Summer</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初识Java_第二天]]></title>
    <url>%2F2017%2F07%2F16%2F%E5%88%9D%E8%AF%86Java_%E7%AC%AC%E4%BA%8C%E5%A4%A9_2017-7-16%2F</url>
    <content type="text"><![CDATA[8种基本数据类型 (๑•ω•̀๑） 逻辑类型：boolean整数类型：byte、short、int、long字符类型：char浮点类型：float、double long型常量用后缀L来表示 float常量后面必须要有后缀f或F 对于double常量，后缀有“d”或“D”，但允许省略后缀. 对于byte型内存分配给1个字节，占8位 . 对于short型变量，内存分配给2个字节，占16位. 对于char型变量，内存分配给2个字节，占16位 . 对于int型变量，内存分配给4个字节（byte）,占32位. 对于float型变量，内存分配给4个字节，占32位。 对于long型变量，内存分配给8个字节，占64位. 对于double型变量，内存分配给8个字节，占64位 . 输入、输出数据 (๑´ㅂ`๑)int number = 0; Scanner reader = new Scanner(System.in); number = reader.nextInt(); System.out.println(); //输出数据后换行 System.out.print(); //输出数据后不换行 System.out.printf(&quot;%d,%f&quot;,12, 23.78); %s输出字符串数据 如果需要输出的字符串的长度较长，可以将字符串分解成几部分，然后使用并置符号：“+”将它们首尾相接 eg: public class Hello2{ public static void main(String args[]){ System.out.println("你好，"+ "很高兴认识你"); } } 数组 ٩(๑❛ᴗ❛๑)۶ 为数组分配元素的格式如下：数组名 = new 数组元素的类型[数组元素的个数]; 数组的声明和分配空间可以在声明时同时完成：float boy []=new float[4]; length字段的使用 对于一维数组，“数组名.length”的值就是数组中元素的个数； boy.length==4 对于二维数组“数组名.length”的值是它含有的一维数组的个数 eg：int [][] a = new int[3][8]; a.length的值是3. a[0].length，a[1].length，a[2].length的值是8 数组属于引用型变量，两个相同类型的数组如果具有相同的引用，它们就有完全相同的元素。 折半法 (๑•ω•̀๑）从小到大排序的数组，只要判断数据是否和数组中间的值相等，如果不相等，当该数据小于数组中间元素的值，就在数组的前一半数据中继续折半找，否则就在数组的后一半数据中继续折半找，可以比较快地判断该数据是否在数组中。eg: import java.util.*; class Example2_5 { public static void main(String args[]) { int start=0,end,middle; int a[] = {12,45,67,89,123,-45,67}; int N = a.length; for(int i=0; i&lt;N; i++) { //选择法排序数组 for(int j = i+1; j &lt; N;j++){ if(a[j] &lt; a[i]){ int t = a[j]; a[j] = a[i]; a[i] = t; } } } System.out.println(Arrays. toString(a)); Scanner scanner = new Scanner(System.in); System.out.println(&quot;输入整数，程序判断该整数是否在数组中:&quot;); int number = scanner.nextInt(); int count =0 ; end = N; middle=(start+end)/2; while(number!=a[middle]){ if(number&gt;a[middle]) start=middle; else if(number&lt;a[middle]) end=middle; middle=(start+end)/2; count++; if(count&gt;N/2) break; } if(count&gt;N/2) System.out.printf(&quot;%d不在数组中.\n&quot;,number); else System.out.printf(&quot;%d在数组中.\n&quot;,number); } } 其它 (๑•ω•̀๑）标识符由字母、下划线、美元符号和数字组成，并且第一个字符不能是数字字符(关键字不能做标识符). 体验٩(•̤̀ᵕ•̤́๑) 环境总是出错，不会配置 public static void main(String args[]) //（）中的东西不能省略 System.out.printf//S大写 汗= = 加油]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>2017Summer</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初识Java_第一天]]></title>
    <url>%2F2017%2F07%2F15%2F%E5%88%9D%E8%AF%86Java_%E7%AC%AC%E4%B8%80%E5%A4%A9_2017-7-15%2F</url>
    <content type="text"><![CDATA[特点 (๑•ω•̀๑） Java与平台无关 （字节码由Java虚拟机负责解释运行，即Java虚拟机负责将字节码翻译成本地计算机的机器码，并将机器码交给本地的操作系统来运行。 ） 多线程 动态 （基本组成单元就是类，自己编写的+从类库中引入的，而类又是运行时动态装载的，这就使得Java可以在分布环境中动态地维护程序及类库。 ） 安装+配置环境变量 (๑´ㅂ`๑) Java SE平台 百度搜素“[jdk1.8官方下载][1]” 选择适合版本 jdk-8u131-windows-x64.exe 选择安装路径界面。 （为了便于今后设置环境变量，修改默认的安装路径为：E:\jdk1.8 ） JDK平台提供的Java编译器（javac.exe）和Java解释器（java.exe）位于Java安装目录的\bin文件夹中. 右键“计算机”-“属性”-“系统特性”-“高级属性设置”-“环境变量”-添加系统环境变量JAVA_HOME，让该环境变量的值是JDK目录结构的根目录，例如E:\jdk1.8 “环境变量”-“系统变量(S)”-path-“编辑(I) ”-%JAVA_HOME%\bin;C………… 开发步骤 ٩(๑❛ᴗ❛๑)۶ 编写源文件:扩展名必须是 .java。 编译Java源程序:用Java编译器（javac.exe）编译源文件，得到字节码文件。 运行Java程序:使用Java解释器（java.exe）来解释执行字节码文件。 实战1 ( • ̀ω•́ )eg1： 用文本编辑器编辑代码。 如果源文件中有多个类，那么只能有一个类是public类；如果有一个类是public类，那么源文件的名字必须与这个类的名字完全相同，扩展名是java。 一个Java应用程序必须有一个类含有public static void main（String args[ ]）方法，称这个类是应用程序的主类。 Hello.java是由两个名字分别为Hello和Student的类组成。 Hello.java。我们将Hello.java保存到E:\chapter1文件夹中。 public class Hello { public static void main (String args[]) { System.out.println("大家好!"); System.out.println("Nice to meet you"); Student stu = new Student(); stu.speak("We are students"); } } class Student { public void speak(String s) { System.out.println(s); } } E:\chapter1&gt; javac Hello.java （使用javac编译源文件） E:\chapter1> java Hello （使用java解释器运行程序） 反编译 ٩(๑❛ᴗ❛๑)۶ JDK提供的反编译器是javap.exe 如果想反编译例子1中的Hello.class，可使用javap命令：javap Hello.class ，例如：E:\chapter1> javap Hello.class 如果想反编译类库中的Date类（其包名是java.util）Date.class，可使用javap命令：javap java.util.Date.class，例如：E:\chapter1> javap java.util.Date.class 其它 (๑•ω•̀๑） 单行注释 // 多行注释 / / 体验٩(•̤̀ᵕ•̤́๑) 下载安装+配置环境变量比较麻烦 cmd写+编译+跑出第一个Java还是很神奇的 加油]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>2017Summer</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Our story begins]]></title>
    <url>%2F2017%2F04%2F02%2FOur%20story%20begins%2F</url>
    <content type="text"><![CDATA[《十二》❤《十二》里这样唱： 你是 九月夏天滚烫的浪 你是 忽而大雨瓢泼的向往 你是 飞越山川河流的大梦一场 你是 整夜白雪茫茫的路旁 你是 南半球的年少风光 ☂你是无言 你是对望 你是 隔着落地窗的翅膀 你是 小城艳阳高照的清香 你是 无力抗拒不停追逐的磁场 你是 傍晚落日余晖的向往 你是 我不能拥抱的短暂理想 你是旅途 你是故乡 ✿ 你是 不愿停下的难忘情长 你是 逃离废墟的路途茫茫 你是 忽明忽暗的不悔时光 你是 一束生命全力绽放 你是 我认真书写的一笔一划 你是 几缕发丝的错误生长 ➷你是 解药 你是营养 你是 四海为家的回头牵肠 你是 我独享的遗憾和渴望 你是 我不愿醒来的梦啊 柔情一场 ☁我的名字叫 难忘 ❁ ❤ 此文写给小星星（个咋知嘚仨）ヾ(o◕∀◕)ﾉヾ About this article:❤ “和你在一起的时光嘛=w= 总是很开心a ” “废话要是和我在一起不开心那我岂不是太失败了/doge” 所以 为你而写 这繁华一世w ❀ by 罐罐]]></content>
      <categories>
        <category>生活</category>
      </categories>
  </entry>
</search>